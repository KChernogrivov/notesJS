/* ТИПЫ ДАННЫХ */

/*
    number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
    bigint для целых чисел произвольной длины.
    string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
    boolean для true/false.
    null для неизвестных значений – отдельный тип, имеющий одно значение null.
    undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
    object для более сложных структур данных.
    symbol для уникальных идентификаторов.

    Number(undefined) = NaN

    null - "ПУСТОЙ, ПУСТОЙ, ЗНАЧЕНИЕ НЕИЗВЕСТНО"
    Для typeof(null) возвращается "object" – это ошибка в языке, на самом деле это не объект.

    в то время Undefined - переменная объявлена, но значение не присвоено.

    let name = "Ilya";

    // выражение - число 1
    alert( `hello ${1}` ); // hello 1

    // выражение - строка "name"
    alert( `hello ${"name"}` ); // hello name

    // выражение - переменная, вставим её в строку
    alert( `hello ${name}` ); // hello Ilya
 */

/* МАТЕМАТИЧЕСКИЕ ДЕЙСТВИЯ */

/*
    Let num1 = 2;
    Let num1 = -num1; (Будет -2) В этом случае минус – УНАРНЫЙ

    Let num2 = 3;
    Let num2 = num2 - num2 В этом случае минус – БИНАРНЫЙ

    При сложении 1 или 2 операнда, если хотя бы 1 операнд является строкой, второй также приводится к строке,
    в то время как деление и вычитание приводит к числу ВСЕГДА.

    Бинарный плюс ( + ) преобразует не числа в числа, но не меняет знаки.
    let x = 1;
    alert( +x ); // 1

    +true = 1;
    +”” = 0;

    null становится 0 после численного преобразования.
    undefined становится NaN после численного преобразования.
    Пробельные символы, такие как \t и \n, по краям строки игнорируются при преобразовании в число,
    так что строка " \t \n", аналогично пустой строке, становится 0 после численного преобразования.

    Инкремент - ++
    Декремент - --

    Когда оператор идёт после переменной — это «постфиксная форма»: counter++.
    Возвращает старое значение
    «Префиксная форма» — это когда оператор идёт перед переменной: ++counter.
    возвращает новое значение

    let a = (1 + 2, 3 + 4);
    alert( a ); // 7 (результат вычисления 3 + 4)

    Оператор Запятая имеет очень низкий приоритет
    Пожалуйста, обратите внимание, что оператор , имеет очень низкий приоритет, ниже =, поэтому скобки важны в приведённом выше примере.
    Без них в a = 1 + 2, 3 + 4 сначала выполнится +, суммируя числа в a = 3, 7,
    затем оператор присваивания = присвоит a = 3, а то, что идёт дальше, будет игнорировано. Всё так же, как в (a = 1 + 2), 3 + 4.

    // три операции в одной строке
    for (a = 1, b = 3, c = a * b; a < 10; a++) {
    ...
    }
    Такие трюки используются во многих JavaScript-фреймворках. Вот почему мы упоминаем их.
    Но обычно они не улучшают читабельность кода, поэтому стоит хорошо подумать, прежде чем их использовать.
 */

/* СРАВНЕНИЕ */

/*
    При сравнении двух строк JS сравнивает код букв последовательно, кодировка - UNICODE. (маленькая буква больше заглавной).
    alert( 'Я' > 'А' ); // true
    alert( 'Коты' > 'Кода' ); // true
    alert( 'Сонный' > 'Сон' ); // true
    Сначала сравниваются первые символы строк.
    Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй. Сравнение завершено.
    Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
    Сравнение продолжается, пока не закончится одна из строк.
    Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.

    При сравнении разных типов, JS привод их к числу.
    alert( '2' > 1 ); // true, строка '2' становится числом 2
    alert( '01' == 1 ); // true, строка '01' становится числом 1

    обычное сравнение == привод все к одному типу и сравниет,
    Строгое - не приводит к одному типу.

    undefined и null

    При "мягком сравнении" эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.
    при строгом false.

    При использовании математических операторов и других операторов сравнения < > <= >=
    Значения null/undefined преобразуются к числам:
    null становится 0, а undefined – NaN.

    alert( null > 0 );  // (1) false
    alert( null == 0 ); // (2) false
    alert( null >= 0 ); // (3) true

    alert( undefined > 0 ); // false (1)
    alert( undefined < 0 ); // false (2)
    alert( undefined == 0 ); // false (3)

    Почему же сравнение undefined с нулём всегда ложно?

    На это есть следующие причины:

    Сравнения (1) и (2) возвращают false, потому что undefined преобразуется в NaN, а NaN – это специальное числовое значение, которое возвращает false при любых сравнениях.
    Нестрогое равенство (3) возвращает false, потому что undefined равно только null, undefined и ничему больше.

    5 > 4 → true
    "ананас" > "яблоко" → false
    "2" > "12" → true
    undefined == null → true
    undefined === null → false
    null == "\n0\n" → false
    null === +"\n0\n" → false
    Разъяснения:

    Очевидно, true.
    Используется посимвольное сравнение, поэтому false. "а" меньше, чем "я".
    Снова посимвольное сравнение. Первый символ первой строки "2" больше, чем первый символ второй "1".
    Специальный случай. Значения null и undefined равны только друг другу при нестрогом сравнении.
    Строгое сравнение разных типов, поэтому false.
    Аналогично (4), null равен только undefined.
    Строгое сравнение разных типов.
 */

/* Условное ветвление: if, '?' */

/*

    Оператор представлен знаком вопроса ?. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.

    Синтаксис:
    let result = условие ? значение1 : значение2;

    Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.

    Например:
    let accessAllowed = (age > 18) ? true : false;

    Последовательность операторов вопросительного знака ? позволяет вернуть значение, которое зависит от более чем одного условия.
    Например:

    let age = prompt('Возраст?', 18);

    let message = (age < 3) ? 'Здравствуй, малыш!' :
    (age < 18) ? 'Привет!' :
    (age < 100) ? 'Здравствуйте!' :
    'Какой необычный возраст!';

    alert( message );

    также иногда используют как:
    let company = prompt('Какая компания создала JavaScript?', '');

    (company == 'Netscape') ?
    alert('Верно!') : alert('Неправильно.');
    */

/*  Логические операторы  */

/*
    В JavaScript есть три логических оператора: || (ИЛИ), && (И) и ! (НЕ).
    Если значение не логического типа, то оно к нему приводится в целях вычислений.

    ИЛИ ||

    Вычисляет операнды слева направо.
    Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
    Если все операнды являются ложными (false), возвращает последний из них.
    Значение возвращается в исходном виде, без преобразования.

    Другими словами, цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено.

    Например:

    alert( 1 || 0 ); // 1
    alert( true || 'no matter what' ); // true

    alert( null || 1 ); // 1 (первое истинное значение)
    alert( null || 0 || 1 ); // 1 (первое истинное значение)
    alert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее

    let currentUser = null;
    let defaultUser = "John";

    let name = currentUser || defaultUser || "unnamed";

    alert( name ); // выбирается "John" – первое истинное значение

    Использование присваивания
    let x;

    false || (x = 1);

    alert(x); // 1

    && И

    Оператор && выполняет следующие действия:

    Вычисляет операнды слева направо.
    Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
    Если все операнды были истинными, возвращается последний.
    Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.

    Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое ложное значение, а ИЛИ –  первое истинное.

    Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое ложное значение, а ИЛИ –  первое истинное.

    Примеры:

    // Если первый операнд истинный,
    // И возвращает второй:
    alert( 1 && 0 ); // 0
    alert( 1 && 5 ); // 5

    // Если первый операнд ложный,
    // И возвращает его. Второй операнд игнорируется
    alert( null && 5 ); // null
    alert( 0 && "no matter what" ); // 0
    
    Приоритет оператора && больше, чем у ||
 */